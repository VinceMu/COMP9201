frame table:
struct frame_table_entry{
    size_t  next_empty; //link list record next available entry.
};
 use position of entry in the list(frame table) to represent physical address(i*PAGE_SIZE).

/* frametable initialisation.
 *                 physical memory
 *   0xA000 0000    ______________
 *                 |              |
 *                 |              |
 *                 |______________|
 *                 |______________|<--- page table and first free pointer is here.
 *                 |______________|<--- frame table is here.
 *                 | OS161 kernel |
 *   0x0000 0000   |______________|
 *
 *   1. first get the location where the frame table should be placed.
 *              call ram_getfirstfree();
 *
 *   2. calculate how much pages should be use, and allocate exact number of
 *      space for the frame table entries.
 *              num of pages = total_physical_memory_size / each_page_size
 *
 *   3. initialized each entry.
 */
 
 
 
 page table:
 /*
 * page table is a hashed list. the number of entries is 2
 * times of physical frames. Half of them is use for hashed index,
 * another half is used to deal will hash collision.
 *
 *  _____________                _______________
 * |             |              |               |
 * | hashed index|  --map--->   |physical frame |
 * |_____________|              |_______________|
 * |             |
 * |external link|
 * |_____________|
 *
 * page table entry:
 *     _________________________________________________________________________
 *    | frame address | page address | ID | should have a next entry pointer...|
 *     —————————————————————————————————————————————————————————————————————————
 */
 struct page_table_entry{
    paddr_t frame_addr;
    vaddr_t page_addr;
    struct addrspace *pid;
    int next_entry; //did not implement.....have no time
};



addrspace:
struct addrspace {
	struct as_region *as_regions_start; 
};

region:
struct as_region{
    vaddr_t vbase;
    size_t npages;
    unsigned int as_permission
    struct as_region* next;
};
 
-------------------------------------------------------------------------
when vm_fault happend, program check page table first, if no entry is avalid,
check the if the virtual is the the region of address space. if it faild, return
EINVAL. If success, allocate physical memory and insert this address into page table,
write address into TLB.

